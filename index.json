[{"content":"Ich bin Attila Krick, selbstst√§ndiger Experte f√ºr PowerShell, T-SQL und .NET mit √ºber 30 Jahren praktischer Erfahrung. Ich unterst√ºtze Unternehmen und IT-Abteilungen dabei, effiziente Softwarel√∂sungen zu entwickeln, Prozesse zu automatisieren und internes Fachwissen aufzubauen. Die L√∂sungen, die ich entwickle, sind so konzipiert, dass Kunden diese sp√§ter eigenst√§ndig anpassen und erweitern k√∂nnen.\nMeine Leistungen: PowerShell, .NET \u0026amp; SQL-Optimierung f√ºr IT-Experten Ich biete meine Schulungen, Workshops und Vortr√§ge sowohl vor Ort als auch remote/online an, um maximale Flexibilit√§t f√ºr Unternehmen und Teilnehmer zu gew√§hrleisten.\nPowerShell Entwicklung und Optimierung von Automatisierungs-Skripten PowerShell-Schulungen f√ºr Einsteiger, Fortgeschrittene \u0026amp; Experten Sicherheitsanalysen und Ma√ünahmen gegen Schwachstellen .NET-Entwicklung Entwicklung von Client-/Server-Anwendungen, WPF, Webservices und Backend-Diensten .NET-Beratung f√ºr Unternehmen und IT-Abteilungen Unterst√ºtzung bestehender Entwicklerteams SQL Server Datenbankdesign, Administration und Performance-Optimierung SQL-Schulungen f√ºr Administratoren, Entwickler und Nicht-Techniker Content \u0026amp; Dokumentation Erstellung von SEO-optimierten Fachartikeln f√ºr Blogs und technische Dokumentationen Entwicklung individueller Seminar-Dokumentationen als PDF oder in gedruckter Form Kunden \u0026amp; Praxisbeispiele Ausgew√§hlte Kunden Schulungen \u0026amp; Workshops: GFU AG, ComConsult GmbH, Bechtle AG Projektumsetzung \u0026amp; Beratung: √ñffentlicher Dienst, Zulieferindustrie, kommunale Verwaltungen Erfolgsgeschichten aus Projekten Effizienzsteigerung durch PowerShell-Automatisierung ‚úÖ Problem: Ein Kunde musste t√§glich manuell 500+ Benutzerkonten in Active Directory verwalten.\n‚úÖ L√∂sung: Entwicklung eines PowerShell-Skripts zur Automatisierung der Verwaltung.\n‚úÖ Ergebnis: Einsparung von √ºber 15 Arbeitsstunden pro Woche.\nSQL Performance-Tuning f√ºr schnelleres Reporting ‚úÖ Problem: Langsame SQL-Abfragen verhinderten Echtzeitanalysen im Controlling.\n‚úÖ L√∂sung: Index-Optimierung und Refactoring ineffizienter Stored Procedures.\n‚úÖ Ergebnis: Abfragen liefen 85% schneller, wodurch Berichte in Minuten statt Stunden verf√ºgbar waren.\nWarum Kunden mit mir zusammenarbeiten Tiefes und breites Wissen in IT, Mechanik, Elektronik, P√§dagogik, kaufm√§nnischen und milit√§rischen Bereichen √úber 1500 erfolgreiche Trainingstage Individuelle Beratung und ma√ügeschneiderte L√∂sungen Flexibel einsetzbar remote \u0026amp; vor Ort (europaweit) Klare und verst√§ndliche Kommunikation auf technischer und Management-Ebene Kundenstimmen \u0026ldquo;Entwickler wusste, wovon er redet, und man hat gemerkt, dass er viel Expertise besitzt.\u0026rdquo; \u0026ldquo;Attila ist fachlich sehr gut aufgestellt, was es ihm erleichtert, Wissen zu vermitteln.\u0026rdquo; \u0026ldquo;W√§hrend des gesamten Seminars wurde es nicht langweilig. Attila hat das Thema so spannend gemacht, wie es geht!\u0026rdquo; \u0026ldquo;Sehr professionell mit einem riesigen Wissensspektrum. Themen wurden strukturiert angegangen und Fragen pr√§zise beantwortet.\u0026rdquo; \u0026ldquo;Trainer war klasse. Attila gibt sich viel M√ºhe und geht auf jede Frage ein.\u0026rdquo; \u0026ldquo;Auf alle Fragen wurde eingegangen. Antworten waren klar und verst√§ndlich, mit Fokus auf selbstst√§ndige Anwendung.\u0026rdquo; Kontakt \u0026amp; Zusammenarbeit Interessiert an einer Zusammenarbeit? Ich freue mich auf Ihre Anfrage!\nüìß Kontakt aufnehmen\n","permalink":"https://attilakrick.com/leistungen/","summary":"\u003cp\u003eIch bin Attila Krick, selbstst√§ndiger Experte f√ºr \u003cstrong\u003ePowerShell\u003c/strong\u003e, \u003cstrong\u003eT-SQL\u003c/strong\u003e und \u003cstrong\u003e.NET\u003c/strong\u003e mit √ºber 30 Jahren praktischer Erfahrung. Ich unterst√ºtze Unternehmen und IT-Abteilungen dabei, effiziente Softwarel√∂sungen zu entwickeln, Prozesse zu automatisieren und internes Fachwissen aufzubauen. Die L√∂sungen, die ich entwickle, sind so konzipiert, dass Kunden diese sp√§ter eigenst√§ndig anpassen und erweitern k√∂nnen.\u003c/p\u003e\n\u003ch2 id=\"meine-leistungen-powershell-net--sql-optimierung-f√ºr-it-experten\"\u003eMeine Leistungen: PowerShell, .NET \u0026amp; SQL-Optimierung f√ºr IT-Experten\u003c/h2\u003e\n\u003cp\u003eIch biete meine \u003cstrong\u003eSchulungen, Workshops und Vortr√§ge sowohl vor Ort als auch remote/online an\u003c/strong\u003e, um maximale Flexibilit√§t f√ºr Unternehmen und Teilnehmer zu gew√§hrleisten.\u003c/p\u003e","title":"IT-Dienstleistungen \u0026 Schulungen"},{"content":"Warum PowerShell mit VS Code nutzen? Viele Entwickler und IT-Administratoren setzen Visual Studio Code (VS Code) als bevorzugte Entwicklungsumgebung f√ºr PowerShell-Skripte ein. Die Kombination aus leichtgewichtigem Editor, leistungsstarken Erweiterungen und integrierten Debugging-Features macht VS Code zu einer idealen Plattform f√ºr PowerShell-Entwicklung. Zus√§tzlich erm√∂glicht es eine einheitliche Entwicklungserfahrung √ºber verschiedene Betriebssysteme hinweg, da VS Code sowohl unter Windows als auch auf macOS und Linux verf√ºgbar ist.\nInstallation der PowerShell-Erweiterung Damit VS Code PowerShell optimal unterst√ºtzt, ben√∂tigst du die PowerShell-Erweiterung. Diese bietet:\nSyntaxhervorhebung f√ºr besser lesbaren Code IntelliSense f√ºr Autovervollst√§ndigung und Parameterhilfe Debugging-Funktionen, um Skripte effizient zu testen Integrierte PowerShell-Konsole f√ºr direkten Code-Output Erweiterte Fehleranalyse f√ºr bessere Fehlersuche Schritte zur Installation VS Code herunterladen und installieren\nDownload VS Code PowerShell-Erweiterung hinzuf√ºgen\n√ñffne VS Code Gehe zu Erweiterungen (Ctrl + Shift + X) Suche nach PowerShell Klicke auf Installieren PowerShell als Standard-Terminal setzen\n√ñffne die Einstellungen (Strg + ,) Suche nach terminal.integrated.defaultProfile.windows Setze den Wert auf PowerShell VS Code f√ºr PowerShell optimieren Automatische Formatierung aktivieren Um sicherzustellen, dass dein Code sauber und einheitlich bleibt, kannst du die Auto-Formatierung aktivieren:\n√ñffne die VS Code Einstellungen (Strg + ,). Suche nach editor.formatOnSave. Setze den Wert auf true. 1\u0026#34;editor.formatOnSave\u0026#34;: true Standard-Terminal auf PowerShell setzen Falls VS Code ein anderes Terminal nutzt, kannst du es wie folgt √§ndern:\nGehe zu den Einstellungen (Strg + ,). Suche nach terminal.integrated.defaultProfile.windows. Setze den Wert auf PowerShell. 1\u0026#34;terminal.integrated.defaultProfile.windows\u0026#34;: \u0026#34;PowerShell\u0026#34; Erweiterte Tastenkombinationen f√ºr PowerShell nutzen Aktuelle Zeile ausf√ºhren: In .ps1-Dateien kann die aktuelle Zeile mit F8 ausgef√ºhrt werden. Skript starten: Dr√ºcke F5, um das gesamte Skript auszuf√ºhren. Fehlersuche starten: Setze einen Breakpoint und starte das Debugging mit F5. Debugging von PowerShell-Skripten Eine der gr√∂√üten St√§rken von VS Code ist das integrierte Debugging f√ºr PowerShell. So kannst du Fehler schneller finden und beheben.\nBreakpoints setzen und Debugging starten Breakpoint setzen: Klicke links neben eine Zeilennummer. Debugging starten (F5). Variablen √ºberwachen und durch den Code schrittweise gehen. Eingabeaufforderung f√ºr interaktives Debugging nutzen, um Werte in Echtzeit zu ver√§ndern. Tipps f√ºr eine produktive Umgebung Zus√§tzliche VS Code Extensions \u0026ldquo;Bracket Pair Colorizer\u0026rdquo; f√ºr farbige Klammern \u0026ldquo;Code Spell Checker\u0026rdquo; f√ºr weniger Tippfehler \u0026ldquo;PowerShell Pro Tools\u0026rdquo; f√ºr erweiterte Skriptfunktionen Fazit Die Integration von PowerShell in Visual Studio Code macht die Entwicklung deutlich komfortabler und effizienter. Mit der richtigen Konfiguration, Debugging-Tools und erweiterten Features kannst du produktiver arbeiten und deine Skripte schneller optimieren.\nNutze die gezeigten Einstellungen und steigere deine Produktivit√§t mit VS Code und PowerShell!\n","permalink":"https://attilakrick.com/posts/vscode_starter/","summary":"\u003ch2 id=\"warum-powershell-mit-vs-code-nutzen\"\u003eWarum PowerShell mit VS Code nutzen?\u003c/h2\u003e\n\u003cp\u003eViele Entwickler und IT-Administratoren setzen \u003cem\u003eVisual Studio Code (VS Code)\u003c/em\u003e als bevorzugte Entwicklungsumgebung f√ºr PowerShell-Skripte ein. Die Kombination aus \u003cem\u003eleichtgewichtigem Editor, leistungsstarken Erweiterungen und integrierten Debugging-Features\u003c/em\u003e macht VS Code zu einer idealen Plattform f√ºr PowerShell-Entwicklung. Zus√§tzlich erm√∂glicht es eine einheitliche Entwicklungserfahrung √ºber verschiedene Betriebssysteme hinweg, da VS Code sowohl unter Windows als auch auf macOS und Linux verf√ºgbar ist.\u003c/p\u003e\n\u003ch2 id=\"installation-der-powershell-erweiterung\"\u003eInstallation der PowerShell-Erweiterung\u003c/h2\u003e\n\u003cp\u003eDamit VS Code PowerShell optimal unterst√ºtzt, ben√∂tigst du die \u003cstrong\u003ePowerShell-Erweiterung\u003c/strong\u003e. Diese bietet:\u003c/p\u003e","title":"Integration von PowerShell in Visual Studio Code"},{"content":"Warum sollte man die PowerShell-Hilfe nutzen? PowerShell ist ein m√§chtiges Werkzeug, aber die Vielzahl an Cmdlets, Parametern und M√∂glichkeiten kann √ºberw√§ltigend sein. Die integrierte Hilfe erleichtert den Einstieg und hilft dir, effizient zu arbeiten, indem sie dir schnell die ben√∂tigten Informationen liefert. Sie ist:\nOffline verf√ºgbar - keine Internetverbindung erforderlich. Direkt integriert - kein zus√§tzliches Tool notwendig. Kontextbezogen - zeigt relevante Parameter und Beispiele f√ºr das gew√§hlte Cmdlet. Flexibel - von kurzen Zusammenfassungen bis hin zu detaillierten Anwendungsf√§llen. Gerade f√ºr Administratoren, Entwickler und Automatisierungsaufgaben ist es unerl√§sslich, die Hilfe effektiv zu nutzen.\nDie PowerShell-Hilfe aktualisieren Standardm√§√üig ist die Hilfe in PowerShell nicht vollst√§ndig installiert. Daher sollte sie einmalig heruntergeladen und regelm√§√üig aktualisiert werden:\n1Update-Help -Module * -UICulture en-US Dadurch erh√§ltst du die neuesten Hilfedateien f√ºr deine PowerShell-Version und kannst auch offline darauf zugreifen.\nHilfe zu einem bestimmten Cmdlet abrufen Um die Hilfe f√ºr ein spezifisches Cmdlet anzuzeigen, verwende Get-Help:\n1Get-Help Get-Process Dadurch erh√§ltst du eine Kurzbeschreibung. Wenn du mehr Details ben√∂tigst:\n1Get-Help Get-Process -Detailed F√ºr konkrete Anwendungsbeispiele:\n1Get-Help Get-Process -Examples Falls du die komplette Dokumentation mit allen Parametern und Erkl√§rungen sehen willst:\n1Get-Help Get-Process -Full Falls du eine grafische Darstellung bevorzugst, gibt es diese M√∂glichkeit:\n1Get-Help Get-Process -ShowWindow about_-Themen f√ºr tiefere Einblicke nutzen Neben der Hilfe f√ºr einzelne Cmdlets gibt es auch Dokumentationen zu grundlegenden Konzepten von PowerShell. Diese sind unter about_-Themen erreichbar:\n1Get-Help about_Functions Das zeigt eine Einf√ºhrung in PowerShell-Funktionen. Weitere n√ºtzliche Themen sind:\nabout_Variables - alles √ºber Variablen about_Scripts - Skripting-Grundlagen about_Execution_Policies - Sicherheitsrichtlinien f√ºr Skripte Du kannst die verf√ºgbaren about_-Themen auflisten mit:\n1Get-Help about_* Alternative Quellen: VS Code, Copilot \u0026amp; Co Neben der eingebauten Hilfe gibt es weitere M√∂glichkeiten, um Informationen zu PowerShell zu erhalten:\nVS Code mit PowerShell-Extension bietet Autovervollst√§ndigung und Tooltips f√ºr Cmdlets. GitHub \u0026amp; Microsoft-Dokumentation enthalten offizielle Anleitungen. Chatbots und KI-Tools wie GitHub Copilot k√∂nnen Codevorschl√§ge liefern, aber nicht immer korrekt sein. Fazit Die PowerShell-Hilfe ist ein unverzichtbares Werkzeug, um effizient zu arbeiten. Nutze sie regelm√§√üig, um dein Wissen zu erweitern und schneller L√∂sungen zu finden. Teste jetzt die gezeigten Befehle in deiner PowerShell-Session! üöÄ\n","permalink":"https://attilakrick.com/posts/powershell-hilfe_nutzen/","summary":"\u003ch2 id=\"warum-sollte-man-die-powershell-hilfe-nutzen\"\u003eWarum sollte man die PowerShell-Hilfe nutzen?\u003c/h2\u003e\n\u003cp\u003ePowerShell ist ein m√§chtiges Werkzeug, aber die Vielzahl an Cmdlets, Parametern und M√∂glichkeiten kann √ºberw√§ltigend sein. Die integrierte Hilfe erleichtert den Einstieg und hilft dir, effizient zu arbeiten, indem sie dir schnell die ben√∂tigten Informationen liefert. Sie ist:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eOffline verf√ºgbar\u003c/strong\u003e - keine Internetverbindung erforderlich.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDirekt integriert\u003c/strong\u003e - kein zus√§tzliches Tool notwendig.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKontextbezogen\u003c/strong\u003e - zeigt relevante Parameter und Beispiele f√ºr das gew√§hlte Cmdlet.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFlexibel\u003c/strong\u003e - von kurzen Zusammenfassungen bis hin zu detaillierten Anwendungsf√§llen.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGerade f√ºr Administratoren, Entwickler und Automatisierungsaufgaben ist es unerl√§sslich, die Hilfe effektiv zu nutzen.\u003c/p\u003e","title":"Wie man die PowerShell-Hilfe benutzt"},{"content":"Best Practices f√ºr PowerShell-Skripting 1. Verwende aussagekr√§ftige Variablennamen Nutze sprechende Variablennamen, um die Lesbarkeit und Wartbarkeit zu verbessern:\n1$logDateiPfad = \u0026#34;C:\\Logs\\error.log\u0026#34; 2$benutzerListe = Get-ADUser -Filter * 2. Kommentare f√ºr bessere Verst√§ndlichkeit F√ºge sinnvolle Kommentare hinzu, um die Nachvollziehbarkeit zu erh√∂hen:\n1# Ermittelt alle aktiven Benutzer und speichert sie in einer Variablen 2$aktiveBenutzer = Get-ADUser -Filter {Enabled -eq $true} 3. Nutze Try-Catch-Finally f√ºr Fehlerbehandlung Ein gutes Fehlerhandling macht Skripte robuster:\n1Try { 2 Get-Item \u0026#34;C:\\NichtVorhandeneDatei.txt\u0026#34; 3} Catch { 4 Write-Host \u0026#34;Fehler: $_\u0026#34; -ForegroundColor Red 5} Finally { 6 Write-Host \u0026#34;Skript abgeschlossen.\u0026#34; 7} 4. Setze Funktionen f√ºr wiederverwendbaren Code ein Funktionen helfen, Code sauber zu strukturieren:\n1Function Get-FreierSpeicher { 2 Param($Laufwerk) 3 Get-PSDrive -Name $Laufwerk | Select-Object Used, Free 4} 5. Verwende Module f√ºr gr√∂√üere Projekte Strukturiere gr√∂√üere Skripte mit Modulen:\n1New-ModuleManifest -Path \u0026#34;C:\\MeinModul\\MeinModul.psd1\u0026#34; 6. Parameter validieren Nutze [Validate*]-Attribute, um Parameter sicherer zu machen:\n1Function Set-BenutzerPasswort { 2 Param( 3 [Parameter(Mandatory)] 4 [ValidatePattern(\u0026#34;^[a-zA-Z0-9]{8,}$\u0026#34;)] 5 [string]$NeuesPasswort 6 ) 7 # Passwort setzen 8} 7. Logging in Skripten implementieren Protokolliere wichtige Aktionen, um Fehler zu analysieren:\n1Function Write-Log { 2 Param([string]$Nachricht) 3 \u0026#34;$(Get-Date) - $Nachricht\u0026#34; | Out-File \u0026#34;C:\\Logs\\script.log\u0026#34; -Append 4} 8. Automatisierte Tests mit Pester nutzen Verwende Pester, um Skripte zu testen:\n1Describe \u0026#34;Get-FreierSpeicher Tests\u0026#34; { 2 It \u0026#34;Soll eine Ausgabe mit Werten haben\u0026#34; { 3 Get-FreierSpeicher C | Should -Not -BeNullOrEmpty 4 } 5} 9. Skripte digital signieren Sicherheit erh√∂hen durch signierte Skripte:\n1Set-AuthenticodeSignature -FilePath \u0026#34;MeinSkript.ps1\u0026#34; -Certificate (Get-ChildItem Cert:\\CurrentUser\\My -CodeSigningCert) 10. Performance optimieren Nutze effiziente Methoden f√ºr hohe Performance:\n1# Vermeide langsame Schleifen mit ForEach-Object 2$BenutzerNamen = (Get-ADUser -Filter *).SamAccountName ","permalink":"https://attilakrick.com/posts/best_practices_powershell_skripting/","summary":"\u003ch2 id=\"best-practices-f√ºr-powershell-skripting\"\u003eBest Practices f√ºr PowerShell-Skripting\u003c/h2\u003e\n\u003ch3 id=\"1-verwende-aussagekr√§ftige-variablennamen\"\u003e1. Verwende aussagekr√§ftige Variablennamen\u003c/h3\u003e\n\u003cp\u003eNutze sprechende Variablennamen, um die Lesbarkeit und Wartbarkeit zu verbessern:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59\"\u003e1\u003c/span\u003e\u003cspan\u003e$logDateiPfad = \u003cspan style=\"color:#b8bb26\"\u003e\u0026#34;C:\\Logs\\error.log\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59\"\u003e2\u003c/span\u003e\u003cspan\u003e$benutzerListe = \u003cspan style=\"color:#fabd2f\"\u003eGet-ADUser\u003c/span\u003e -Filter *\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"2-kommentare-f√ºr-bessere-verst√§ndlichkeit\"\u003e2. Kommentare f√ºr bessere Verst√§ndlichkeit\u003c/h3\u003e\n\u003cp\u003eF√ºge sinnvolle Kommentare hinzu, um die Nachvollziehbarkeit zu erh√∂hen:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59\"\u003e1\u003c/span\u003e\u003cspan\u003e\u003cspan style=\"color:#928374;font-style:italic\"\u003e# Ermittelt alle aktiven Benutzer und speichert sie in einer Variablen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#756d59\"\u003e2\u003c/span\u003e\u003cspan\u003e$aktiveBenutzer = \u003cspan style=\"color:#fabd2f\"\u003eGet-ADUser\u003c/span\u003e -Filter {Enabled \u003cspan style=\"color:#fe8019\"\u003e-eq\u003c/span\u003e $true}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"3-nutze-try-catch-finally-f√ºr-fehlerbehandlung\"\u003e3. Nutze \u003ccode\u003eTry-Catch-Finally\u003c/code\u003e f√ºr Fehlerbehandlung\u003c/h3\u003e\n\u003cp\u003eEin gutes Fehlerhandling macht Skripte robuster:\u003c/p\u003e","title":"PowerShell-Scripting Best Practices - Effiziente Automatisierung und Sicherheit"},{"content":"PowerShell 7.6 und PowerShell 7.5: Was ist neu? PowerShell 7.5 und 7.6 bringen viele neue Funktionen mit sich. Es basiert auch auf .NET 9, was bedeutet, dass es keinen Long-Term Support (LTS) hat.\nIn diesem Artikel werfen wir einen Blick auf die wichtigsten Neuerungen in PowerShell 7.5 und 7.6, erkl√§ren die Unterschiede und geben eine Empfehlung, ob sich ein Upgrade lohnt.\nEmpfehlung: Lohnt sich der Umstieg auf PowerShell 7.5 bzw. 7.6 ? F√ºr produktive Umgebungen:\nBleibe bei PowerShell 7.4 (LTS), da PowerShell 7.6 und 7.5 kein LTS-Support hat und 7.6 sich noch in der Preview-Phase befindet.\nF√ºr Entwickler \u0026amp; Power-User:\nPowerShell 7.6 bietet spannende neue Features und ist ideal f√ºr Tests oder f√ºr Benutzer, die immer die neuesten Funktionen ausprobieren m√∂chten.\nWarte auf PowerShell 8.0, wenn du LTS-Unterst√ºtzung ben√∂tigst. PowerShell 7.5: Die wichtigsten Neuerungen PowerShell 7.5 wurde als stabile Version ver√∂ffentlicht und enth√§lt viele Optimierungen:\nVerbesserte JSON-Verarbeitung PowerShell 7.5 verbessert die ConvertTo-Json-Funktion, um gro√üe und komplexe Objekte besser zu serialisieren.\n1$Data = @{ 2 Name = \u0026#34;PowerShell 7.5\u0026#34; 3 Features = @(\u0026#34;Optimierte JSON-Ausgabe\u0026#34;, \u0026#34;Mehr Sicherheit\u0026#34;, \u0026#34;Neue Cmdlets\u0026#34;) 4} 5$Data | ConvertTo-Json -Depth 3 Optimierte Sicherheit und Signierung Unterst√ºtzung f√ºr Windows Defender Application Control (WDAC), um Skripte besser abzusichern. Erweiterte Sicherheitsfunktionen f√ºr Set-AuthenticodeSignature. Neue Cmdlets in PowerShell 7.5 PowerShell 7.5 f√ºhrte mehrere neue Cmdlets ein:\nInvoke-PSCommand - Verbesserte Remoting-Steuerung. Get-ProcessInfo - Detailliertere Prozess√ºberwachung. Start-PSProfile - Leistungs√ºberwachung f√ºr PowerShell-Skripte. PowerShell 7.6: Was ist neu? PowerShell 7.6 bringt weitere Verbesserungen mit sich.\nNeue Cmdlets in PowerShell 7.6 PowerShell 7.6 bringt neun neue Cmdlets mit:\nGet-FileHash - Unterst√ºtzt nun SHA-3. Test-JsonSchema - Pr√ºft JSON-Daten auf Schema-Konformit√§t. ConvertFrom-Base64 / ConvertTo-Base64 - Base64 Encoding/Decoding direkt in PowerShell. Get-CommandHistory - Erweitert die Verwaltung der Befehls-Historie. Invoke-RestMethod - Verbesserte Fehlerbehandlung. Test-NetworkConnection - Bessere Netzwerkpr√ºfung. Get-EnvironmentVariable - Neuer Zugriff auf Umgebungsvariablen. Set-Clipboard / Get-Clipboard - Verbesserte Copy-Paste-Funktionalit√§t. Beispiel f√ºr ConvertFrom-Base64:\n1$encoded = \u0026#34;SGVsbG8gV2VsdA==\u0026#34; 2[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($encoded)) Verbesserte ForEach-Object -Parallel Verarbeitung PowerShell 7.6 verbessert das Multithreading erheblich:\n11..10 | ForEach-Object -Parallel { \u0026#34;Zahl: $_\u0026#34; } Performance-Verbesserungen** Speicherverwaltung wurde weiter optimiert. Schnellere Verarbeitung von gro√üen Dateien. Verbesserte Unterst√ºtzung f√ºr Linux/macOS. Bekannte Probleme Kein LTS-Support ‚Üí Nicht f√ºr produktive Umgebungen geeignet. Out-GridView fehlt weiterhin auf macOS/Linux. Kompatibilit√§tsprobleme mit √§lteren Modulen, die auf .NET 9 basieren. Fazit: Solltest du auf PowerShell 7.6 upgraden? Nutzungstyp Empfehlung Produktive Umgebungen Nein, bleibe bei PowerShell 7.4 (LTS) Entwicklung \u0026amp; Tests Ja, aber nur f√ºr nicht-kritische Workloads Power-User \u0026amp; Neugierige Ja, um die neuen Features zu testen Falls du ein stabiles System ben√∂tigst, warte auf PowerShell 8.0 (LTS).\nRelease-Daten PowerShell 7.5 (Stable): Ver√∂ffentlicht im Dezember 2024. PowerShell 7.6 (Preview): Erste Vorschauversion im M√§rz 2025. Dieser Artikel wird aktualisiert, sobald neue Informationen zu PowerShell 7.6 verf√ºgbar sind.\n","permalink":"https://attilakrick.com/posts/neuerungen_powershell_75_76/","summary":"\u003ch2 id=\"powershell-76-und-powershell-75-was-ist-neu\"\u003ePowerShell 7.6 und PowerShell 7.5: Was ist neu?\u003c/h2\u003e\n\u003cp\u003ePowerShell 7.5 und 7.6 bringen viele neue Funktionen mit sich. Es basiert auch auf \u003cstrong\u003e.NET 9\u003c/strong\u003e, was bedeutet, dass es \u003cstrong\u003ekeinen Long-Term Support (LTS)\u003c/strong\u003e hat.\u003c/p\u003e\n\u003cp\u003eIn diesem Artikel werfen wir einen Blick auf die wichtigsten Neuerungen in \u003cstrong\u003ePowerShell 7.5 und 7.6\u003c/strong\u003e, erkl√§ren die Unterschiede und geben eine Empfehlung, ob sich ein Upgrade lohnt.\u003c/p\u003e\n\u003ch2 id=\"empfehlung-lohnt-sich-der-umstieg-auf-powershell-75-bzw-76-\"\u003eEmpfehlung: Lohnt sich der Umstieg auf PowerShell 7.5 bzw. 7.6 ?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eF√ºr produktive Umgebungen:\u003c/strong\u003e\u003c/p\u003e","title":"Neuerungen PowerShell 7.5 und 7.6"},{"content":"Unterschiede zwischen PowerShell und anderen Shells wie der Eingabeaufforderung oder Bash PowerShell, die Windows-Eingabeaufforderung (CMD) und Bash sind drei verschiedene Shell-Umgebungen, die jeweils unterschiedliche Einsatzbereiche und Funktionen haben. In diesem Artikel vergleichen wir diese Shells und beleuchten die wichtigsten Unterschiede.\n1. Grundlegendes Konzept Shell Basis-Technologie Hauptplattform PowerShell Objektbasiert (OOP) Windows, Linux, macOS CMD (Eingabeaufforderung) Textbasiert Windows Bash Textbasiert Linux, macOS 2. Unterschiede in der Syntax PowerShell: Objektbasiert PowerShell arbeitet mit Objekten, nicht nur mit Text. Das bedeutet, dass Befehle strukturierte Daten ausgeben, die einfach weiterverarbeitet werden k√∂nnen.\n1# Listet alle laufenden Prozesse mit detaillierten Informationen 2Get-Process | Select-Object Name, Id, CPU CMD: Textbasiert Die Windows-Eingabeaufforderung gibt reinen Text aus. Es gibt keine native M√∂glichkeit, komplexe Datenstrukturen zu √ºbergeben.\n1REM Listet laufende Prozesse als reinen Text 2TASKLIST | findstr \u0026#34;notepad\u0026#34; Bash: Textbasiert mit Pipes Bash kann ebenfalls nur mit Text umgehen, erm√∂glicht aber leistungsstarke Pipelines mit grep, awk und sed.\n1# Listet laufende Prozesse und filtert nach \u0026#34;firefox\u0026#34; 2ps aux | grep firefox 3. Pipeline-Verarbeitung PowerShell unterscheidet sich von CMD und Bash dadurch, dass es mit Objekten arbeitet, anstatt nur mit Text-Streams.\nShell Pipeline verarbeitet PowerShell Objekte CMD Reiner Text Bash Reiner Text Beispiel in PowerShell:\n1# Sortiert Prozesse nach CPU-Auslastung 2Get-Process | Sort-Object CPU -Descending Das w√§re in Bash oder CMD schwieriger, da man hier mit regul√§ren Ausdr√ºcken arbeiten m√ºsste.\n4. Plattform√ºbergreifende Nutzung W√§hrend CMD nur unter Windows l√§uft, sind sowohl PowerShell als auch Bash plattform√ºbergreifend verf√ºgbar.\nShell Plattformen PowerShell Windows, Linux, macOS CMD Windows Bash Linux, macOS PowerShell Core (pwsh) erm√∂glicht es, PowerShell auf Linux und macOS zu nutzen.\n5. Skripting-F√§higkeiten PowerShell ist eine vollst√§ndige Skriptsprache mit Unterst√ºtzung f√ºr Funktionen, Variablen und Module.\n1# Funktion zur Prozess√ºberwachung 2function Check-Process { 3 param([string]$ProcessName) 4 Get-Process -Name $ProcessName -ErrorAction SilentlyContinue 5} Bash hingegen nutzt Shell-Skripte mit einer einfacheren Syntax:\n1# Funktion zur Prozess√ºberwachung 2check_process() { 3 ps aux | grep \u0026#34;$1\u0026#34; 4} CMD hat nur begrenzte Skript-Funktionen und kann mit Batch-Dateien (.bat) genutzt werden.\nFazit PowerShell bietet moderne, objektorientierte Automatisierung, w√§hrend CMD und Bash eher f√ºr einfache Textverarbeitung und klassische Systemadministration gedacht sind. PowerShell ist besonders f√ºr Windows-Administratoren die beste Wahl, w√§hrend Bash unter Linux und macOS bevorzugt wird.\n","permalink":"https://attilakrick.com/posts/unterschied_ps_vs_bash/","summary":"\u003ch2 id=\"unterschiede-zwischen-powershell-und-anderen-shells-wie-der-eingabeaufforderung-oder-bash\"\u003eUnterschiede zwischen PowerShell und anderen Shells wie der Eingabeaufforderung oder Bash\u003c/h2\u003e\n\u003cp\u003ePowerShell, die Windows-Eingabeaufforderung (CMD) und Bash sind drei verschiedene Shell-Umgebungen, die jeweils unterschiedliche Einsatzbereiche und Funktionen haben. In diesem Artikel vergleichen wir diese Shells und beleuchten die wichtigsten Unterschiede.\u003c/p\u003e\n\u003ch3 id=\"1-grundlegendes-konzept\"\u003e1. Grundlegendes Konzept\u003c/h3\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eShell\u003c/th\u003e\n          \u003cth\u003eBasis-Technologie\u003c/th\u003e\n          \u003cth\u003eHauptplattform\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003ePowerShell\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eObjektbasiert (OOP)\u003c/td\u003e\n          \u003ctd\u003eWindows, Linux, macOS\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eCMD (Eingabeaufforderung)\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eTextbasiert\u003c/td\u003e\n          \u003ctd\u003eWindows\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003eBash\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eTextbasiert\u003c/td\u003e\n          \u003ctd\u003eLinux, macOS\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"2-unterschiede-in-der-syntax\"\u003e2. Unterschiede in der Syntax\u003c/h3\u003e\n\u003ch4 id=\"powershell-objektbasiert\"\u003ePowerShell: Objektbasiert\u003c/h4\u003e\n\u003cp\u003ePowerShell arbeitet mit \u003cstrong\u003eObjekten\u003c/strong\u003e, nicht nur mit Text. Das bedeutet, dass Befehle strukturierte Daten ausgeben, die einfach weiterverarbeitet werden k√∂nnen.\u003c/p\u003e","title":"Unterschiede zwischen PowerShell und anderen Shells"},{"content":"Warum Entity Framework Core nutzen? Entity Framework Core (EF Core) ist das bevorzugte Object-Relational Mapping (ORM)-Framework f√ºr .NET-Entwickler. Es erm√∂glicht eine einfache und effiziente Interaktion mit relationalen Datenbanken, ohne direkt SQL schreiben zu m√ºssen.\nVorteile von EF Core:\nPlattform√ºbergreifend - Unterst√ºtzt Windows, Linux und macOS. Leistungsstark \u0026amp; flexibel - Unterst√ºtzt verschiedene Datenbankanbieter (SQL Server, PostgreSQL, SQLite etc.). Code First \u0026amp; Database First - Erm√∂glicht flexible Entwicklungsmethoden. Integriertes Change Tracking - Automatische Verwaltung von √Ñnderungen an Datenbankeintr√§gen. Migrationen \u0026amp; Modellvalidierung - Versionierung der Datenbankstruktur direkt im Code. Installation von Entity Framework Core EF Core wird als NuGet-Paket installiert. Um EF Core zu nutzen, f√ºge die Pakete zu deinem .NET-Projekt hinzu:\nInstallation mit .NET CLI 1# Basis-Paket f√ºr EF Core 2dotnet add package Microsoft.EntityFrameworkCore 3 4# Paket f√ºr die SQL Server-Unterst√ºtzung 5dotnet add package Microsoft.EntityFrameworkCore.SqlServer 6 7# Paket f√ºr Migrationen 8dotnet add package Microsoft.EntityFrameworkCore.Tools Installation mit Package Manager Falls du Visual Studio verwendest, kannst du die Pakete auch √ºber die NuGet-Paketverwaltung hinzuf√ºgen:\nVisual Studio √∂ffnen Projekt laden Tools -\u0026gt; NuGet-Paket-Manager -\u0026gt; Paketverwaltung f√ºr L√∂sung Microsoft.EntityFrameworkCore suchen und installieren Erste Schritte mit EF Core Um EF Core in einem Projekt zu nutzen, erstelle eine DbContext-Klasse und definiere deine Modelle.\nBeispiel: Eine einfache Product-Entit√§t 1public class Product 2{ 3 public int Id { get; set; } 4 public string Name { get; set; } 5 public decimal Price { get; set; } 6} DbContext erstellen Die DbContext-Klasse verwaltet die Verbindung zur Datenbank:\n1public class AppDbContext : DbContext 2{ 3 public DbSet\u0026lt;Product\u0026gt; Products { get; set; } 4 5 protected override void OnConfiguring(DbContextOptionsBuilder options) 6 { 7 options.UseSqlServer(\u0026#34;Server=.;Database=MyAppDB;Trusted_Connection=True;\u0026#34;); 8 } 9} Migrationen und Datenbankverwaltung EF Core erm√∂glicht eine einfache Verwaltung der Datenbankstruktur mit Migrationen.\nMigration erstellen 1dotnet ef migrations add InitialCreate Migration anwenden 1dotnet ef database update Abfragen mit LINQ EF Core nutzt LINQ (Language Integrated Query), um Datenbankabfragen direkt in C# zu formulieren.\nBeispiel: Daten abrufen 1using (var context = new AppDbContext()) 2{ 3 var products = context.Products.Where(p =\u0026gt; p.Price \u0026gt; 50).ToList(); 4 foreach (var product in products) 5 { 6 Console.WriteLine($\u0026#34;{product.Name}: {product.Price} EUR\u0026#34;); 7 } 8} Beispiel: Einf√ºgen eines neuen Produkts 1using (var context = new AppDbContext()) 2{ 3 var newProduct = new Product { Name = \u0026#34;Laptop\u0026#34;, Price = 999.99M }; 4 context.Products.Add(newProduct); 5 context.SaveChanges(); 6} Tipps f√ºr den produktiven Einsatz von EF Core Verwende AsNoTracking(), wenn Daten nur gelesen werden, um Performance zu verbessern. Nutze Lazy Loading sparsam, um unerwartete Datenbankaufrufe zu vermeiden. Verwalte Verbindungen richtig, um Speicherlecks zu vermeiden. Nutze Migrations sauber, um Probleme bei der Datenbankversionierung zu verhindern. Fazit Entity Framework Core erleichtert die Arbeit mit Datenbanken erheblich und bietet viele n√ºtzliche Funktionen f√ºr .NET-Entwickler. Mit der richtigen Konfiguration und Best Practices kannst du das volle Potenzial von EF Core aussch√∂pfen und performante Anwendungen entwickeln.\n","permalink":"https://attilakrick.com/posts/efcore/","summary":"\u003ch2 id=\"warum-entity-framework-core-nutzen\"\u003eWarum Entity Framework Core nutzen?\u003c/h2\u003e\n\u003cp\u003eEntity Framework Core (EF Core) ist das bevorzugte \u003cstrong\u003eObject-Relational Mapping (ORM)-Framework\u003c/strong\u003e f√ºr .NET-Entwickler. Es erm√∂glicht eine einfache und effiziente Interaktion mit relationalen Datenbanken, ohne direkt SQL schreiben zu m√ºssen.\u003c/p\u003e\n\u003cp\u003eVorteile von EF Core:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePlattform√ºbergreifend\u003c/strong\u003e - Unterst√ºtzt Windows, Linux und macOS.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLeistungsstark \u0026amp; flexibel\u003c/strong\u003e - Unterst√ºtzt verschiedene Datenbankanbieter (SQL Server, PostgreSQL, SQLite etc.).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCode First \u0026amp; Database First\u003c/strong\u003e - Erm√∂glicht flexible Entwicklungsmethoden.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIntegriertes Change Tracking\u003c/strong\u003e - Automatische Verwaltung von √Ñnderungen an Datenbankeintr√§gen.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMigrationen \u0026amp; Modellvalidierung\u003c/strong\u003e - Versionierung der Datenbankstruktur direkt im Code.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"installation-von-entity-framework-core\"\u003eInstallation von Entity Framework Core\u003c/h2\u003e\n\u003cp\u003eEF Core wird als NuGet-Paket installiert. Um EF Core zu nutzen, f√ºge die Pakete zu deinem .NET-Projekt hinzu:\u003c/p\u003e","title":"Entity Framework Core - Was du als .NET-Entwickler wissen musst"}]